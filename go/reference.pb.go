// Code generated by protoc-gen-go. DO NOT EDIT.
// source: reference.proto

package reference

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	any "github.com/golang/protobuf/ptypes/any"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

//*
// pVersion is an enumeration value which defines a variety of parameters for
// use by Argon2id. This ensures that all hosts will be able to validate a
// given entry in an appropriate amount of time.
//
// +----+----+--------------------+------+-----------+---------+
// | id | fn |        salt        | time |   memory  | threads |
// +----+----+--------------------+------+-----------+---------+
// |  1 | id | 0x25b946ebc0b36173 |    1 | 64 * 1000 |       4 |
// +----+----+--------------------+------+-----------+---------+
//
// Salt 0x25b946ebc0b36173 for id 1 was chosen using the output of Python's
// hex() function with the input 2718281828459045235 - the first 19 numbers of
// euler's constant, as retrieved from here:
//
// http://www.gutenberg.org/files/127/127.txt
//
// This results in a perfectly sized 8 byte constant - 0x25b946ebc0b36173.
type Argon2IdSigSource_Argon2Consts int32

const (
	Argon2IdSigSource_ID_1 Argon2IdSigSource_Argon2Consts = 0
)

var Argon2IdSigSource_Argon2Consts_name = map[int32]string{
	0: "ID_1",
}

var Argon2IdSigSource_Argon2Consts_value = map[string]int32{
	"ID_1": 0,
}

func (x Argon2IdSigSource_Argon2Consts) String() string {
	return proto.EnumName(Argon2IdSigSource_Argon2Consts_name, int32(x))
}

func (Argon2IdSigSource_Argon2Consts) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6b165e33ad62994c, []int{0, 0}
}

//*
// All of the different types of encodings a slug can be in!
type Reference_Encoding int32

const (
	//*
	// Argued to be most human usable - used for crypto addresses
	Reference_BASE58 Reference_Encoding = 0
	//*
	// This is the base64url version mind you - its meant to be used in a
	// URL!
	Reference_BASE64 Reference_Encoding = 1
	//*
	// This is the RFC1924 Base85, not Ascii85. For when you have a lot of
	// bits and not enough places to shove them.
	Reference_BASE85 Reference_Encoding = 2
)

var Reference_Encoding_name = map[int32]string{
	0: "BASE58",
	1: "BASE64",
	2: "BASE85",
}

var Reference_Encoding_value = map[string]int32{
	"BASE58": 0,
	"BASE64": 1,
	"BASE85": 2,
}

func (x Reference_Encoding) String() string {
	return proto.EnumName(Reference_Encoding_name, int32(x))
}

func (Reference_Encoding) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_6b165e33ad62994c, []int{1, 0}
}

//*
// Type for configuring parameters of an Argon2idSigSource.
type Argon2IdSigSource struct {
	PVersion             Argon2IdSigSource_Argon2Consts `protobuf:"varint,1,opt,name=pVersion,proto3,enum=reference.Argon2IdSigSource_Argon2Consts" json:"pVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                       `json:"-"`
	XXX_unrecognized     []byte                         `json:"-"`
	XXX_sizecache        int32                          `json:"-"`
}

func (m *Argon2IdSigSource) Reset()         { *m = Argon2IdSigSource{} }
func (m *Argon2IdSigSource) String() string { return proto.CompactTextString(m) }
func (*Argon2IdSigSource) ProtoMessage()    {}
func (*Argon2IdSigSource) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b165e33ad62994c, []int{0}
}

func (m *Argon2IdSigSource) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Argon2IdSigSource.Unmarshal(m, b)
}
func (m *Argon2IdSigSource) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Argon2IdSigSource.Marshal(b, m, deterministic)
}
func (m *Argon2IdSigSource) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Argon2IdSigSource.Merge(m, src)
}
func (m *Argon2IdSigSource) XXX_Size() int {
	return xxx_messageInfo_Argon2IdSigSource.Size(m)
}
func (m *Argon2IdSigSource) XXX_DiscardUnknown() {
	xxx_messageInfo_Argon2IdSigSource.DiscardUnknown(m)
}

var xxx_messageInfo_Argon2IdSigSource proto.InternalMessageInfo

func (m *Argon2IdSigSource) GetPVersion() Argon2IdSigSource_Argon2Consts {
	if m != nil {
		return m.PVersion
	}
	return Argon2IdSigSource_ID_1
}

//*
// Reference is the main payload which is matched to a short key.
//
// The marshalled structure is hashed using the signature source specified
// within to generate the appropriate short stub.
type Reference struct {
	//*
	// Actual reference which is pointed to. MUST be in URI format. SHOULD be
	// an officially supported protocol, however the reference is not invalid
	// if the protocol is not known.
	//
	// Reference MUST be smaller than 512 bytes large.
	Reference string `protobuf:"bytes,1,opt,name=reference,proto3" json:"reference,omitempty"`
	//*
	// Timestamp of when this reference was created. Obviously this isn't
	// enforcable except to prevent it from traveling into the future.
	Created *timestamp.Timestamp `protobuf:"bytes,2,opt,name=created,proto3" json:"created,omitempty"`
	//*
	// Timestamp of when this reference should become invalid. After this
	// time, the reference will become invalid.
	Expires *timestamp.Timestamp `protobuf:"bytes,3,opt,name=expires,proto3" json:"expires,omitempty"`
	//*
	// Encoding of the slug
	SlugEncoding Reference_Encoding `protobuf:"varint,4,opt,name=slugEncoding,proto3,enum=reference.Reference_Encoding" json:"slugEncoding,omitempty"`
	//*
	// sigsource holds a single sigsource configuration which specifies how to
	// recreate the reference slug
	//
	// Types that are valid to be assigned to Sigsource:
	//	*Reference_Argon2Sig
	Sigsource isReference_Sigsource `protobuf_oneof:"sigsource"`
	//*
	// Client/implementation specific data for potentially tracking the
	// reference. May include whatever is desired by whatever generates the
	// reference.
	SourceMeta           *any.Any `protobuf:"bytes,50,opt,name=sourceMeta,proto3" json:"sourceMeta,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Reference) Reset()         { *m = Reference{} }
func (m *Reference) String() string { return proto.CompactTextString(m) }
func (*Reference) ProtoMessage()    {}
func (*Reference) Descriptor() ([]byte, []int) {
	return fileDescriptor_6b165e33ad62994c, []int{1}
}

func (m *Reference) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Reference.Unmarshal(m, b)
}
func (m *Reference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Reference.Marshal(b, m, deterministic)
}
func (m *Reference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Reference.Merge(m, src)
}
func (m *Reference) XXX_Size() int {
	return xxx_messageInfo_Reference.Size(m)
}
func (m *Reference) XXX_DiscardUnknown() {
	xxx_messageInfo_Reference.DiscardUnknown(m)
}

var xxx_messageInfo_Reference proto.InternalMessageInfo

func (m *Reference) GetReference() string {
	if m != nil {
		return m.Reference
	}
	return ""
}

func (m *Reference) GetCreated() *timestamp.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

func (m *Reference) GetExpires() *timestamp.Timestamp {
	if m != nil {
		return m.Expires
	}
	return nil
}

func (m *Reference) GetSlugEncoding() Reference_Encoding {
	if m != nil {
		return m.SlugEncoding
	}
	return Reference_BASE58
}

type isReference_Sigsource interface {
	isReference_Sigsource()
}

type Reference_Argon2Sig struct {
	Argon2Sig *Argon2IdSigSource `protobuf:"bytes,10,opt,name=argon2Sig,proto3,oneof"`
}

func (*Reference_Argon2Sig) isReference_Sigsource() {}

func (m *Reference) GetSigsource() isReference_Sigsource {
	if m != nil {
		return m.Sigsource
	}
	return nil
}

func (m *Reference) GetArgon2Sig() *Argon2IdSigSource {
	if x, ok := m.GetSigsource().(*Reference_Argon2Sig); ok {
		return x.Argon2Sig
	}
	return nil
}

func (m *Reference) GetSourceMeta() *any.Any {
	if m != nil {
		return m.SourceMeta
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Reference) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Reference_Argon2Sig)(nil),
	}
}

func init() {
	proto.RegisterEnum("reference.Argon2IdSigSource_Argon2Consts", Argon2IdSigSource_Argon2Consts_name, Argon2IdSigSource_Argon2Consts_value)
	proto.RegisterEnum("reference.Reference_Encoding", Reference_Encoding_name, Reference_Encoding_value)
	proto.RegisterType((*Argon2IdSigSource)(nil), "reference.Argon2idSigSource")
	proto.RegisterType((*Reference)(nil), "reference.Reference")
}

func init() { proto.RegisterFile("reference.proto", fileDescriptor_6b165e33ad62994c) }

var fileDescriptor_6b165e33ad62994c = []byte{
	// 329 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x90, 0x41, 0x4f, 0xfa, 0x30,
	0x18, 0xc6, 0x19, 0x10, 0xfe, 0xec, 0x85, 0xfc, 0x9d, 0x8d, 0x87, 0x49, 0x30, 0x92, 0x9d, 0xf0,
	0x32, 0xe2, 0x04, 0xc3, 0xc1, 0xcb, 0x50, 0x12, 0x3d, 0x78, 0xe9, 0x8c, 0x57, 0x33, 0x46, 0x69,
	0x9a, 0x40, 0xbb, 0xb4, 0x25, 0x91, 0x8f, 0xe0, 0xb7, 0x36, 0x76, 0x74, 0x43, 0x49, 0xf4, 0xd6,
	0x3c, 0xef, 0xf3, 0xbc, 0xcf, 0xfb, 0x2b, 0x9c, 0x48, 0xb2, 0x22, 0x92, 0xf0, 0x8c, 0x84, 0xb9,
	0x14, 0x5a, 0x20, 0xb7, 0x14, 0x7a, 0xe7, 0x54, 0x08, 0xba, 0x26, 0x23, 0x33, 0x58, 0x6c, 0x57,
	0xa3, 0x94, 0xef, 0x0a, 0x57, 0xef, 0xf2, 0xe7, 0x48, 0xb3, 0x0d, 0x51, 0x3a, 0xdd, 0xe4, 0x85,
	0x21, 0xd0, 0x70, 0x1a, 0x4b, 0x2a, 0x78, 0xc4, 0x96, 0x09, 0xa3, 0x89, 0xd8, 0xca, 0x8c, 0xa0,
	0x39, 0xb4, 0xf3, 0x57, 0x22, 0x15, 0x13, 0xdc, 0x77, 0x06, 0xce, 0xf0, 0x7f, 0x74, 0x15, 0x56,
	0xfd, 0x47, 0xfe, 0xbd, 0x72, 0x2f, 0xb8, 0xd2, 0x0a, 0x97, 0xd1, 0xc0, 0x87, 0xee, 0xe1, 0x04,
	0xb5, 0xa1, 0xf9, 0xf4, 0xf0, 0x76, 0xed, 0xd5, 0x82, 0x8f, 0x06, 0xb8, 0xd8, 0x2e, 0x44, 0x7d,
	0xa8, 0x60, 0x4c, 0x9f, 0x8b, 0x2b, 0x01, 0x8d, 0xe1, 0x5f, 0x26, 0x49, 0xaa, 0xc9, 0xd2, 0xaf,
	0x0f, 0x9c, 0x61, 0x27, 0xea, 0x85, 0x05, 0x54, 0x68, 0xa1, 0xc2, 0x17, 0x0b, 0x85, 0xad, 0xf5,
	0x2b, 0x45, 0xde, 0x73, 0x26, 0x89, 0xf2, 0x1b, 0x7f, 0xa7, 0xf6, 0x56, 0x14, 0x43, 0x57, 0xad,
	0xb7, 0x74, 0xce, 0x33, 0xb1, 0x64, 0x9c, 0xfa, 0x4d, 0x03, 0x7f, 0x71, 0x00, 0x5f, 0x5e, 0x1d,
	0x5a, 0x13, 0xfe, 0x16, 0x41, 0x77, 0xe0, 0xa6, 0x06, 0x3a, 0x61, 0xd4, 0x07, 0x53, 0xdd, 0xff,
	0xed, 0xf3, 0x1e, 0x6b, 0xb8, 0x0a, 0xa0, 0x31, 0x80, 0x32, 0xf2, 0x33, 0xd1, 0xa9, 0x1f, 0x99,
	0xf8, 0xd9, 0xd1, 0xe5, 0x31, 0xdf, 0xe1, 0x03, 0x5f, 0x10, 0x42, 0xbb, 0xec, 0x07, 0x68, 0xcd,
	0xe2, 0x64, 0x3e, 0x99, 0x7a, 0x35, 0xfb, 0xbe, 0x1d, 0x7b, 0x8e, 0x7d, 0x4f, 0x27, 0x5e, 0x7d,
	0xd6, 0x01, 0x57, 0x31, 0x5a, 0x2c, 0x58, 0xb4, 0xcc, 0xda, 0x9b, 0xcf, 0x00, 0x00, 0x00, 0xff,
	0xff, 0x35, 0x82, 0x53, 0x87, 0x62, 0x02, 0x00, 0x00,
}
